<!--Для того чтобы использовать AJAX следует всеголишь запросить сервис $http который позволяет работать с AJAX,
далее следует вызвать один из методов которые предоставляет этот сервис(в зависимости от типа запроса который вы хотите сформировать)
затем нужно определить метод который будет выполнятся при успешном запросе и который будет выполнятся если запрос не удался (при необходимости).
Так же для того чтобы вы могли получить доступ к файлу с расширением *json следует внести изменения в файл web.config-->
<!--Методы сревиса $http
    get(url, config) выполняет GET запрос по указанному URL, config - конфигурационный объект.
    post(url, data, config) выполняет POST запрос по указанному URL, data - данные которые передаются в запросе, config - конфигурационный объект.
    delete(url, config) выполняет DELETE запрос по указанному URL, config - конфигурационный объект.
    put(url, data, config) выполняет PUT запрос по указанному URL, data - данные которые передаются в запросе, config - конфигурационный объект.
    head(url, config) выполняет HEAD запрос по указанному URL, config - конфигурационный объект.
    jsonp(url, config) выполняет GET запрос для получения в качестве ответа JavaScript сценария который затем будет выполнен(работа с кроссдоменными запросами JSONP)-->
<!--AngularJS использует технологию promise, суть этой технологии заключается в том что при выполнении асинхронного запроса после его окончания
будет выполнен метод который указан в цепочке. Например метод success является promise так как AJAX запрос асинхронный, и этот метод будет выполнен
после того как запрос получит ответ от сервера.Ниже представлен список методов доступных для манипулирования данными полученными в качестве ответа на запрос от сервера-->
<!--success(fn) вызывает функцию которая определена в аргументах когда запрос выполнен успешно
error(fn) вызывает функцию которая определена в аргументах когда запрос выполнен с ошибкой
then(fn, fn) регистрирует функцию success и функцию error-->

<!--Использование then метода дает ряд преимуществ, помимо того что вы можете в одном методе определить две функции, в качестве аргумента этим функциям
приходит promise объект который содержит дополнительную информацию о запросе:
    data содержит данные запроса
    status содержит статус ответа от сервера
    headers содержит функцию которая позволяет получить заголовок по его имени
    config конфигурационный объект который используется для выполнения запроса -->
    
    <!--Как вы уже видели все типы запросов которые можно выполнить с помощью сервиса $http поддерживают в качестве второго параметра конфигурационный объект,
с помощью которого можно передать дополнительные данные в запросе:
    data содержит данные которые будут переданы в запросе, если в качестве значения указать объект, то AngularJS автоматически сериализует его в JSON
    headers используется для передачи заголовков в запросе
    method устанавливает тип запроса
    params позволяет передать URL параметры
    timeout устанавливает время ожидания ответа от сервера
    transformRequest используется для работы с запросом перед его посылкой на сервер
    transformResponse используется для манипуляции с ответом после того как он пришел от сервера
    url устанавливает URL для запроса
    withCredentials если в качестве параметра указать true то в запрос будут включены cookies для аутентификации
    xsrfHeaderNamexsrfCookieName это свойство используется для ответа на кроссдоменные зарпосы-->
    
    ----------Пример общения с сервером методами GET, POST---------------
    
    .controller("studyCtrl", function ($scope, $http) {
            $scope.getFruits = function () {
                $http.get("../data.json").success(function (responseData) {
                    $scope.fruits = responseData;
                })
            }
            $scope.sendXmlData = function () {
                var config = {
                        headers: {
                            "content-type": "application/xml"
                        },
                        transformRequest: function (data, headers) {
                            var rootElement = angular.element("<xml>");
                            for (var i = 0; i < data.length; i++) {
                                var element = angular.element("<fruit>");
                                element.attr("name", data[i].name);                                
                                element.attr("price", data[i].price);
                                rootElement.append(element);
                            }
                            rootElement.children().wrap("<fruits>");
                            return rootElement.html();
                        }
                }
                $http.post("02_transforming_request.html", $scope.fruits, config);
            }
        });
    
    <!--если вам нужно установить настройки поу молчанию для запросов с помощью $http то для этого нужно воспользоватся сервисом $httpProvider
    свойства $httpProvider:
        defaults.headers.common определяет заголовки по умолчанию которые используются для всех запросов
        defaults.headers.post определяется заголовки которые используются для POST запросов
        defaults.headers.put определяется заголовки которые используются для PUT запросов
        defaults.transformResponse массив функций для трансформации всех ответов
        defaults.transformRequest массив функций для трансформации всех запросов
        interceptors массив фабричных interceptor функций
        withCredentials устанавливает для всех типов запросов настройку аутентификации-->
        
        <!--interceptor(перехватчик) это некий асоциативный массив который содержит в себе функции предназначенные для перехвата запросов или ответов
свойства которые содержит interceptor:
    request функция будет выполнена перед запросом на сервер, в аргументах функции приходит объект config который содержит ранее упомянутые свойства
    requestError функция будет вызвана если предыдущая функция перехватчик запроса сгенерировала ошибку
    response функция будет выполнена когда будет получен ответ от сервера, в аргументы функции попадает объект который содержит ответ от сервера
    responseError функция будет вызвана если предыдущая функция перехватчик ответа сгенерировала ошибку-->
    
     $scope.productsResource = $resource(baseUrl + ":id", { id: "@id" });
    //сервис $resource представляет собой функцию которая используется для описания URL 
    //который используется для взаимодействия с REST, сегмент URL который изменяется описывается выражением ": "
    // например адрес http://localhost:2200/items/23, где 23-id элемента, вторым аргументом является конфигнурационный объект который определяет 
    // откуда будет взят опциональный параметр, каждое свойство этого объекта должно соответствовать параметру из первого аргумента
    //в данном случае значение опционального параметра привязано к значению свойства id из источника данных
    // результатом работы этой функции является некий объект (access object) который можно использовать для выполнения запросов на сервер, он имеет ряд методов:
        //delete(params, product) тип DELETE удаляет объект по указанному id
        //get(id) тип GET возвращает объект по указанному id
        //query() тип GET возвращает все объекты из массива данных
        //remove(params, product) тип DELETE удаляет объект по указанному id
        //save(product) тип POST сохраняет изменения
    //сервис $resource в результате своей работы создает пустой массив, далее использует сервис $http для запроса на сервер,
    // полученные данные записываются в созданный массив, следует быть осторожным так как запрос выполняется асинхронно и массив проинициализируется данными только после его выполнения
    
     //$route сервис может использоватся для изменения url, для этого он содержит несколько свойств и метод:
    //    current - возвращает объект который содержит информацию об активном url
    //    reload() - перезагружает view даже если url не изменился
    //    routes - возвращает коллекцию url которые определены через $routeProvider
    //Так же этот сервис содержит ряд событий которые можно обрабатывать:
    //    $routeChangeStart - генерируется перед изменением URL
    //    $routeChangeSuccess - генерируется после успешного изменения URL
    //    $routeUpdate - генерируется при обновлении URL
    //    $routeChangeError - генерируется если URL нельзя изменить
    
    
